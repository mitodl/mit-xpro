# Generated by Django 2.2.10 on 2020-03-03 17:02

from collections import defaultdict

from django.db import migrations, models

MAX_RUN_TAG_LENGTH = 10
ENROLLABLE_ITEM_ID_SEPARATOR = "+"
TEXT_ID_RUN_SUFFIX_PATTERN = r"\+(?P<run_tag>R\d+)$"


def backfill_run_tags_from_text_id(course_run_qset):  # noqa: D103
    run_tag_map = defaultdict(list)
    for run in course_run_qset:
        potential_run_tag = run.courseware_id.split(ENROLLABLE_ITEM_ID_SEPARATOR)[-1]
        if len(potential_run_tag) > MAX_RUN_TAG_LENGTH:
            continue
        run_tag_map[potential_run_tag].append(run)

    for run_tag, matching_runs in run_tag_map.items():
        # If multiple course runs have the same potential run_tag value in the same course,
        # just set it for the first course run and ignore the rest. They will be assigned a
        # different run_tag value in the next step.
        run_to_update = matching_runs[0]
        run_to_update.run_tag = run_tag
        run_to_update.save()


def backfill_run_tags_from_id(course_run_qset):  # noqa: D103
    for run in course_run_qset:
        run.run_tag = str(run.id)
        run.save()


def backfill_course_run_run_tags(apps, schema_editor):  # noqa: D103
    Course = apps.get_model("courses", "Course")
    CourseRun = apps.get_model("courses", "CourseRun")

    # For all course runs with a start date and a courseware id suffix that is short enough
    # (e.g.: "+R5", "+1T2019"), use that suffix as the run_tag value. Runs without start dates
    # are ignored because it's assumed that they are most likely meant for testing and aren't
    # important enough to need a valid run_tag.
    for course_id in Course.objects.values_list("id", flat=True):
        course_runs_qset = (
            CourseRun.objects.filter(course_id=course_id, run_tag=None)
            .exclude(start_date=None)
            .order_by("start_date")
        )
        backfill_run_tags_from_text_id(course_runs_qset)

    # For all remaining runs, use the course run's own id as the run_tag value. This is just to fill
    # in values so the field can be set to non-null in a future migration.
    remaining_course_runs_qset = CourseRun.objects.filter(run_tag=None)
    backfill_run_tags_from_id(remaining_course_runs_qset)


class Migration(migrations.Migration):
    dependencies = [("courses", "0024_programrun")]

    operations = [
        migrations.RenameField(
            model_name="programrun", old_name="run_suffix", new_name="run_tag"
        ),
        migrations.AddField(
            model_name="courserun",
            name="run_tag",
            field=models.CharField(
                blank=True,
                help_text="A string that identifies the set of runs that this run belongs to (example: 'R2')",
                max_length=10,
                null=True,
            ),
        ),
        migrations.AlterUniqueTogether(
            name="programrun", unique_together={("program", "run_tag")}
        ),
        migrations.RunPython(
            backfill_course_run_run_tags, reverse_code=migrations.RunPython.noop
        ),
        migrations.AlterField(
            model_name="courserun",
            name="run_tag",
            field=models.CharField(
                help_text="A string that identifies the set of runs that this run belongs to (example: 'R2')",
                max_length=10,
            ),
        ),
        migrations.AlterUniqueTogether(
            name="courserun", unique_together={("course", "run_tag")}
        ),
    ]
